; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\stm32f4xx_sai.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_sai.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\Basic\inc -I..\HardWare\IIC -I..\HardWare\SPI -I..\HardWare\USART -I..\HardWare\W25QXX -I..\System\delay -I..\System\sys -I..\User -I..\CMSIS -I.\RTE\_Target_1 -ID:\ProgramFile\Keil5\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\ProgramFile\Keil5\ARM\CMSIS\Include -D__UVISION_VERSION=525 -DSTM32F405xx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\stm32f4xx_sai.crf ..\Basic\src\stm32f4xx_sai.c]
                          THUMB

                          AREA ||i.SAI_ClearFlag||, CODE, READONLY, ALIGN=1

                  SAI_ClearFlag PROC
;;;921      */
;;;922    void SAI_ClearFlag(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_FLAG)
000000  6982              LDR      r2,[r0,#0x18]
;;;923    {
;;;924      /* Check the parameters */
;;;925      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;926      assert_param(IS_SAI_BLOCK_CLEAR_FLAG(SAI_FLAG));
;;;927        
;;;928      /* Clear the selected SAI Block flag */
;;;929      SAI_Block_x->CLRFR |= SAI_FLAG;
000002  430a              ORRS     r2,r2,r1
000004  6182              STR      r2,[r0,#0x18]
;;;930    }
000006  4770              BX       lr
;;;931    
                          ENDP


                          AREA ||i.SAI_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  SAI_ClearITPendingBit PROC
;;;993      */
;;;994    void SAI_ClearITPendingBit(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_IT)
000000  6982              LDR      r2,[r0,#0x18]
;;;995    {
;;;996      /* Check the parameters */
;;;997      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;998      assert_param(IS_SAI_BLOCK_CONFIG_IT(SAI_IT));
;;;999    
;;;1000     /* Clear the selected SAI Block x interrupt pending bit */
;;;1001     SAI_Block_x->CLRFR |= SAI_IT; 
000002  430a              ORRS     r2,r2,r1
000004  6182              STR      r2,[r0,#0x18]
;;;1002   }
000006  4770              BX       lr
;;;1003   
                          ENDP


                          AREA ||i.SAI_Cmd||, CODE, READONLY, ALIGN=1

                  SAI_Cmd PROC
;;;431      */
;;;432    void SAI_Cmd(SAI_Block_TypeDef* SAI_Block_x, FunctionalState NewState)
000000  b121              CBZ      r1,|L3.12|
;;;433    {
;;;434      /* Check the parameters */
;;;435      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;436      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;437      if (NewState != DISABLE)
;;;438      {
;;;439        /* Enable the selected SAI peripheral */
;;;440        SAI_Block_x->CR1 |= SAI_xCR1_SAIEN;
000002  6802              LDR      r2,[r0,#0]
000004  f4423280          ORR      r2,r2,#0x10000
000008  6002              STR      r2,[r0,#0]
00000a  e003              B        |L3.20|
                  |L3.12|
;;;441      }
;;;442      else
;;;443      {
;;;444        /* Disable the selected SAI peripheral */
;;;445        SAI_Block_x->CR1 &= ~(SAI_xCR1_SAIEN);
00000c  6802              LDR      r2,[r0,#0]
00000e  f4223280          BIC      r2,r2,#0x10000
000012  6002              STR      r2,[r0,#0]
                  |L3.20|
;;;446      }
;;;447    }
000014  4770              BX       lr
;;;448    
                          ENDP


                          AREA ||i.SAI_CompandingModeConfig||, CODE, READONLY, ALIGN=1

                  SAI_CompandingModeConfig PROC
;;;511      */
;;;512    void SAI_CompandingModeConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_CompandingMode)
000000  6842              LDR      r2,[r0,#4]
;;;513    {
;;;514      /* Check the parameters */
;;;515      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;516      assert_param(IS_SAI_BLOCK_COMPANDING_MODE(SAI_CompandingMode));
;;;517      /* Clear Companding Mode bits */
;;;518      SAI_Block_x->CR2 &= ~(SAI_xCR2_COMP);
000002  f4224240          BIC      r2,r2,#0xc000
000006  6042              STR      r2,[r0,#4]
;;;519      /* Set new Companding Mode value */
;;;520      SAI_Block_x->CR2 |= SAI_CompandingMode;
000008  6842              LDR      r2,[r0,#4]
00000a  430a              ORRS     r2,r2,r1
00000c  6042              STR      r2,[r0,#4]
;;;521    }
00000e  4770              BX       lr
;;;522    
                          ENDP


                          AREA ||i.SAI_DMACmd||, CODE, READONLY, ALIGN=1

                  SAI_DMACmd PROC
;;;701      */
;;;702    void SAI_DMACmd(SAI_Block_TypeDef* SAI_Block_x, FunctionalState NewState)
000000  b121              CBZ      r1,|L5.12|
;;;703    {
;;;704      /* Check the parameters */
;;;705      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;706      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;707      
;;;708      if (NewState != DISABLE)
;;;709      {
;;;710        /* Enable the selected SAI block mute mode */
;;;711        SAI_Block_x->CR1 |= SAI_xCR1_DMAEN;
000002  6802              LDR      r2,[r0,#0]
000004  f4423200          ORR      r2,r2,#0x20000
000008  6002              STR      r2,[r0,#0]
00000a  e003              B        |L5.20|
                  |L5.12|
;;;712      }
;;;713      else
;;;714      {
;;;715        /* Disable the selected SAI SS output */
;;;716        SAI_Block_x->CR1 &= ~(SAI_xCR1_DMAEN);
00000c  6802              LDR      r2,[r0,#0]
00000e  f4223200          BIC      r2,r2,#0x20000
000012  6002              STR      r2,[r0,#0]
                  |L5.20|
;;;717      }
;;;718    }
000014  4770              BX       lr
;;;719    
                          ENDP


                          AREA ||i.SAI_DeInit||, CODE, READONLY, ALIGN=1

                  SAI_DeInit PROC
;;;181      */
;;;182    void SAI_DeInit(SAI_TypeDef* SAIx)
000000  b510              PUSH     {r4,lr}
;;;183    {
000002  4604              MOV      r4,r0
;;;184      /* Check the parameters */
;;;185      assert_param(IS_SAI_PERIPH(SAIx));
;;;186    
;;;187      /* Enable SAI1 reset state */
;;;188      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SAI1, ENABLE);
000004  2101              MOVS     r1,#1
000006  0588              LSLS     r0,r1,#22
000008  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;189      /* Release SAI1 from reset state */
;;;190      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SAI1, DISABLE);  
00000c  2100              MOVS     r1,#0
00000e  f44f0080          MOV      r0,#0x400000
000012  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;191    }
000016  bd10              POP      {r4,pc}
;;;192    
                          ENDP


                          AREA ||i.SAI_FlushFIFO||, CODE, READONLY, ALIGN=1

                  SAI_FlushFIFO PROC
;;;611      */
;;;612    void SAI_FlushFIFO(SAI_Block_TypeDef* SAI_Block_x)
000000  6841              LDR      r1,[r0,#4]
;;;613    {
;;;614      /* Check the parameters */
;;;615      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;616    
;;;617      /* FIFO flush */
;;;618      SAI_Block_x->CR2 |= SAI_xCR2_FFLUSH;
000002  f0410108          ORR      r1,r1,#8
000006  6041              STR      r1,[r0,#4]
;;;619    }
000008  4770              BX       lr
;;;620    
                          ENDP


                          AREA ||i.SAI_FrameInit||, CODE, READONLY, ALIGN=2

                  SAI_FrameInit PROC
;;;271      */
;;;272    void SAI_FrameInit(SAI_Block_TypeDef* SAI_Block_x, SAI_FrameInitTypeDef* SAI_FrameInitStruct)
000000  b510              PUSH     {r4,lr}
;;;273    {
;;;274      uint32_t tmpreg = 0;
000002  2200              MOVS     r2,#0
;;;275      
;;;276      /* Check the parameters */
;;;277      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;278      
;;;279      /* Check the SAI Block frame parameters */
;;;280      assert_param(IS_SAI_BLOCK_FRAME_LENGTH(SAI_FrameInitStruct->SAI_FrameLength));
;;;281      assert_param(IS_SAI_BLOCK_ACTIVE_FRAME(SAI_FrameInitStruct->SAI_ActiveFrameLength));
;;;282      assert_param(IS_SAI_BLOCK_FS_DEFINITION(SAI_FrameInitStruct->SAI_FSDefinition));
;;;283      assert_param(IS_SAI_BLOCK_FS_POLARITY(SAI_FrameInitStruct->SAI_FSPolarity));
;;;284      assert_param(IS_SAI_BLOCK_FS_OFFSET(SAI_FrameInitStruct->SAI_FSOffset));
;;;285    
;;;286      /* SAI Block_x FRCR Configuration */
;;;287      /* Get the SAI Block_x FRCR value */
;;;288      tmpreg = SAI_Block_x->FRCR;
000004  6882              LDR      r2,[r0,#8]
;;;289      /* Clear FRL, FSALL, FSDEF, FSPOL, FSOFF bits */
;;;290      tmpreg &= FRCR_CLEAR_MASK;
000006  4b08              LDR      r3,|L8.40|
000008  401a              ANDS     r2,r2,r3
;;;291      /* Configure SAI_Block_x Frame: Frame Length, Active Frame Length, Frame Synchronization
;;;292         Definition, Frame Synchronization Polarity and Frame Synchronization Polarity */
;;;293      /* Set FRL bits according to SAI_FrameLength value         */
;;;294      /* Set FSALL bits according to SAI_ActiveFrameLength value */
;;;295      /* Set FSDEF bit according to SAI_FSDefinition value       */
;;;296      /* Set FSPOL bit according to SAI_FSPolarity value         */
;;;297      /* Set FSOFF bit according to SAI_FSOffset value           */
;;;298      tmpreg |= (uint32_t)((uint32_t)(SAI_FrameInitStruct->SAI_FrameLength - 1)  | 
00000a  680b              LDR      r3,[r1,#0]
00000c  1e5b              SUBS     r3,r3,#1
00000e  690c              LDR      r4,[r1,#0x10]
000010  4323              ORRS     r3,r3,r4
000012  688c              LDR      r4,[r1,#8]
000014  4323              ORRS     r3,r3,r4
000016  68cc              LDR      r4,[r1,#0xc]
000018  4323              ORRS     r3,r3,r4
00001a  684c              LDR      r4,[r1,#4]
00001c  1e64              SUBS     r4,r4,#1
00001e  ea432304          ORR      r3,r3,r4,LSL #8
000022  431a              ORRS     r2,r2,r3
;;;299                           SAI_FrameInitStruct->SAI_FSOffset     | 
;;;300                           SAI_FrameInitStruct->SAI_FSDefinition |    
;;;301                           SAI_FrameInitStruct->SAI_FSPolarity   |                        
;;;302                           (uint32_t)((SAI_FrameInitStruct->SAI_ActiveFrameLength - 1) << 8));
;;;303                           
;;;304      /* Write to SAI_Block_x FRCR */
;;;305      SAI_Block_x->FRCR = tmpreg;
000024  6082              STR      r2,[r0,#8]
;;;306    }
000026  bd10              POP      {r4,pc}
;;;307    
                          ENDP

                  |L8.40|
                          DCD      0xfff88000

                          AREA ||i.SAI_FrameStructInit||, CODE, READONLY, ALIGN=1

                  SAI_FrameStructInit PROC
;;;389      */
;;;390    void SAI_FrameStructInit(SAI_FrameInitTypeDef* SAI_FrameInitStruct)
000000  2108              MOVS     r1,#8
;;;391    {
;;;392      /* Reset SAI Frame init structure parameters values */
;;;393      /* Initialize the SAI_FrameLength member */
;;;394      SAI_FrameInitStruct->SAI_FrameLength = 8;
000002  6001              STR      r1,[r0,#0]
;;;395      /* Initialize the SAI_ActiveFrameLength member */
;;;396      SAI_FrameInitStruct->SAI_ActiveFrameLength = 1;
000004  2101              MOVS     r1,#1
000006  6041              STR      r1,[r0,#4]
;;;397      /* Initialize the SAI_FSDefinition member */
;;;398      SAI_FrameInitStruct->SAI_FSDefinition = SAI_FS_StartFrame;
000008  2100              MOVS     r1,#0
00000a  6081              STR      r1,[r0,#8]
;;;399      /* Initialize the SAI_FSPolarity member */
;;;400      SAI_FrameInitStruct->SAI_FSPolarity = SAI_FS_ActiveLow;
00000c  60c1              STR      r1,[r0,#0xc]
;;;401      /* Initialize the SAI_FSOffset member */
;;;402      SAI_FrameInitStruct->SAI_FSOffset = SAI_FS_FirstBit;
00000e  6101              STR      r1,[r0,#0x10]
;;;403    }
000010  4770              BX       lr
;;;404    
                          ENDP


                          AREA ||i.SAI_GetCmdStatus||, CODE, READONLY, ALIGN=1

                  SAI_GetCmdStatus PROC
;;;1015     */
;;;1016   FunctionalState SAI_GetCmdStatus(SAI_Block_TypeDef* SAI_Block_x)
000000  4601              MOV      r1,r0
;;;1017   {
;;;1018     FunctionalState state = DISABLE;
000002  2000              MOVS     r0,#0
;;;1019   
;;;1020     /* Check the parameters */
;;;1021     assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;1022     if ((SAI_Block_x->CR1 & (uint32_t)SAI_xCR1_SAIEN) != 0)
000004  680a              LDR      r2,[r1,#0]
000006  f4023280          AND      r2,r2,#0x10000
00000a  b10a              CBZ      r2,|L10.16|
;;;1023     {
;;;1024       /* The selected SAI Block x EN bit is set (audio frame transfer is ongoing) */
;;;1025       state = ENABLE;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L10.18|
                  |L10.16|
;;;1026     }
;;;1027     else
;;;1028     {
;;;1029       /* The selected SAI Block x EN bit is cleared (SAI Block is disabled and 
;;;1030           all transfers are complete) */
;;;1031       state = DISABLE;
000010  2000              MOVS     r0,#0
                  |L10.18|
;;;1032     }
;;;1033     return state;
;;;1034   }
000012  4770              BX       lr
;;;1035   
                          ENDP


                          AREA ||i.SAI_GetFIFOStatus||, CODE, READONLY, ALIGN=1

                  SAI_GetFIFOStatus PROC
;;;1048     */
;;;1049   uint32_t SAI_GetFIFOStatus(SAI_Block_TypeDef* SAI_Block_x)
000000  4601              MOV      r1,r0
;;;1050   {
;;;1051     uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;1052    
;;;1053     /* Check the parameters */
;;;1054     assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;1055     
;;;1056     /* Get the FIFO level bits */
;;;1057     tmpreg = (uint32_t)((SAI_Block_x->SR & SAI_xSR_FLVL));
000004  694a              LDR      r2,[r1,#0x14]
000006  f40220e0          AND      r0,r2,#0x70000
;;;1058     
;;;1059     return tmpreg;
;;;1060   }
00000a  4770              BX       lr
;;;1061   
                          ENDP


                          AREA ||i.SAI_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  SAI_GetFlagStatus PROC
;;;878      */
;;;879    FlagStatus SAI_GetFlagStatus(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_FLAG)
000000  4602              MOV      r2,r0
;;;880    {
;;;881      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;882      
;;;883      /* Check the parameters */
;;;884      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;885      assert_param(IS_SAI_BLOCK_GET_FLAG(SAI_FLAG));
;;;886      
;;;887      /* Check the status of the specified SAI flag */
;;;888      if ((SAI_Block_x->SR & SAI_FLAG) != (uint32_t)RESET)
000004  6953              LDR      r3,[r2,#0x14]
000006  400b              ANDS     r3,r3,r1
000008  b10b              CBZ      r3,|L12.14|
;;;889      {
;;;890        /* SAI_FLAG is set */
;;;891        bitstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L12.16|
                  |L12.14|
;;;892      }
;;;893      else
;;;894      {
;;;895        /* SAI_FLAG is reset */
;;;896        bitstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L12.16|
;;;897      }
;;;898      /* Return the SAI_FLAG status */
;;;899      return  bitstatus;
;;;900    }
000010  4770              BX       lr
;;;901    
                          ENDP


                          AREA ||i.SAI_GetITStatus||, CODE, READONLY, ALIGN=1

                  SAI_GetITStatus PROC
;;;946      */
;;;947    ITStatus SAI_GetITStatus(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_IT)
000000  b510              PUSH     {r4,lr}
;;;948    {
000002  4602              MOV      r2,r0
;;;949      ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;950      uint32_t  enablestatus = 0;
000006  2300              MOVS     r3,#0
;;;951    
;;;952      /* Check the parameters */
;;;953      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;954      assert_param(IS_SAI_BLOCK_CONFIG_IT(SAI_IT));
;;;955      
;;;956      /* Get the SAI_IT enable bit status */
;;;957      enablestatus = (SAI_Block_x->IMR & SAI_IT) ;
000008  6914              LDR      r4,[r2,#0x10]
00000a  ea040301          AND      r3,r4,r1
;;;958    
;;;959      /* Check the status of the specified SAI interrupt */
;;;960      if (((SAI_Block_x->SR & SAI_IT) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
00000e  6954              LDR      r4,[r2,#0x14]
000010  400c              ANDS     r4,r4,r1
000012  b114              CBZ      r4,|L13.26|
000014  b10b              CBZ      r3,|L13.26|
;;;961      {
;;;962        /* SAI_IT is set */
;;;963        bitstatus = SET;
000016  2001              MOVS     r0,#1
000018  e000              B        |L13.28|
                  |L13.26|
;;;964      }
;;;965      else
;;;966      {
;;;967        /* SAI_IT is reset */
;;;968        bitstatus = RESET;
00001a  2000              MOVS     r0,#0
                  |L13.28|
;;;969      }
;;;970      /* Return the SAI_IT status */
;;;971      return bitstatus;
;;;972    }
00001c  bd10              POP      {r4,pc}
;;;973    
                          ENDP


                          AREA ||i.SAI_ITConfig||, CODE, READONLY, ALIGN=1

                  SAI_ITConfig PROC
;;;845      */
;;;846    void SAI_ITConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_IT, FunctionalState NewState)
000000  b11a              CBZ      r2,|L14.10|
;;;847    { 
;;;848      /* Check the parameters */
;;;849      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;850      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;851      assert_param(IS_SAI_BLOCK_CONFIG_IT(SAI_IT));
;;;852    
;;;853      if (NewState != DISABLE)
;;;854      {
;;;855        /* Enable the selected SAI Block interrupt */
;;;856        SAI_Block_x->IMR |= SAI_IT;
000002  6903              LDR      r3,[r0,#0x10]
000004  430b              ORRS     r3,r3,r1
000006  6103              STR      r3,[r0,#0x10]
000008  e002              B        |L14.16|
                  |L14.10|
;;;857      }
;;;858      else
;;;859      {
;;;860        /* Disable the selected SAI Block interrupt */
;;;861        SAI_Block_x->IMR &= ~(SAI_IT);
00000a  6903              LDR      r3,[r0,#0x10]
00000c  438b              BICS     r3,r3,r1
00000e  6103              STR      r3,[r0,#0x10]
                  |L14.16|
;;;862      }
;;;863    }
000010  4770              BX       lr
;;;864    
                          ENDP


                          AREA ||i.SAI_Init||, CODE, READONLY, ALIGN=2

                  SAI_Init PROC
;;;204      */
;;;205    void SAI_Init(SAI_Block_TypeDef* SAI_Block_x, SAI_InitTypeDef* SAI_InitStruct)
000000  b510              PUSH     {r4,lr}
;;;206    {
000002  4602              MOV      r2,r0
;;;207      uint32_t tmpreg = 0;
000004  2000              MOVS     r0,#0
;;;208      
;;;209      /* Check the parameters */
;;;210      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;211      
;;;212      /* Check the SAI Block parameters */
;;;213      assert_param(IS_SAI_BLOCK_MODE(SAI_InitStruct->SAI_AudioMode));
;;;214      assert_param(IS_SAI_BLOCK_PROTOCOL(SAI_InitStruct->SAI_Protocol));
;;;215      assert_param(IS_SAI_BLOCK_DATASIZE(SAI_InitStruct->SAI_DataSize));
;;;216      assert_param(IS_SAI_BLOCK_FIRST_BIT(SAI_InitStruct->SAI_FirstBit));
;;;217      assert_param(IS_SAI_BLOCK_CLOCK_STROBING(SAI_InitStruct->SAI_ClockStrobing));
;;;218      assert_param(IS_SAI_BLOCK_SYNCHRO(SAI_InitStruct->SAI_Synchro));
;;;219      assert_param(IS_SAI_BLOCK_OUTPUT_DRIVE(SAI_InitStruct->SAI_OUTDRIV));
;;;220      assert_param(IS_SAI_BLOCK_NODIVIDER(SAI_InitStruct->SAI_NoDivider));
;;;221      assert_param(IS_SAI_BLOCK_MASTER_DIVIDER(SAI_InitStruct->SAI_MasterDivider));
;;;222      assert_param(IS_SAI_BLOCK_FIFO_THRESHOLD(SAI_InitStruct->SAI_FIFOThreshold));
;;;223    
;;;224      /* SAI Block_x CR1 Configuration */
;;;225      /* Get the SAI Block_x CR1 value */
;;;226      tmpreg = SAI_Block_x->CR1;
000006  6810              LDR      r0,[r2,#0]
;;;227      /* Clear MODE, PRTCFG, DS, LSBFIRST, CKSTR, SYNCEN, OUTDRIV, NODIV, and MCKDIV bits */
;;;228      tmpreg &= CR1_CLEAR_MASK;
000008  4b0e              LDR      r3,|L15.68|
00000a  4018              ANDS     r0,r0,r3
;;;229      /* Configure SAI_Block_x: Audio mode, Protocol, Data Size, first transmitted bit, Clock strobing 
;;;230         edge, Synchronization mode, Output drive, Master Divider and FIFO level */  
;;;231      /* Set MODE bits according to SAI_AudioMode value       */
;;;232      /* Set PRTCFG bits according to SAI_Protocol value      */
;;;233      /* Set DS bits according to SAI_DataSize value          */
;;;234      /* Set LSBFIRST bit according to SAI_FirstBit value     */
;;;235      /* Set CKSTR bit according to SAI_ClockStrobing value   */
;;;236      /* Set SYNCEN bit according to SAI_Synchro value        */
;;;237      /* Set OUTDRIV bit according to SAI_OUTDRIV value       */
;;;238      /* Set NODIV bit according to SAI_NoDivider value       */
;;;239      /* Set MCKDIV bits according to SAI_MasterDivider value */
;;;240      tmpreg |= (uint32_t)(SAI_InitStruct->SAI_AudioMode     | SAI_InitStruct->SAI_Protocol  |
00000c  e9d13400          LDRD     r3,r4,[r1,#0]
000010  4323              ORRS     r3,r3,r4
000012  688c              LDR      r4,[r1,#8]
000014  4323              ORRS     r3,r3,r4
000016  68cc              LDR      r4,[r1,#0xc]
000018  4323              ORRS     r3,r3,r4
00001a  690c              LDR      r4,[r1,#0x10]
00001c  4323              ORRS     r3,r3,r4
00001e  694c              LDR      r4,[r1,#0x14]
000020  4323              ORRS     r3,r3,r4
000022  698c              LDR      r4,[r1,#0x18]
000024  4323              ORRS     r3,r3,r4
000026  69cc              LDR      r4,[r1,#0x1c]
000028  4323              ORRS     r3,r3,r4
00002a  8c0c              LDRH     r4,[r1,#0x20]
00002c  ea435304          ORR      r3,r3,r4,LSL #20
000030  4318              ORRS     r0,r0,r3
;;;241                           SAI_InitStruct->SAI_DataSize      | SAI_InitStruct->SAI_FirstBit  |  
;;;242                           SAI_InitStruct->SAI_ClockStrobing | SAI_InitStruct->SAI_Synchro   |  
;;;243                           SAI_InitStruct->SAI_OUTDRIV       | SAI_InitStruct->SAI_NoDivider | 
;;;244                           (uint32_t)((SAI_InitStruct->SAI_MasterDivider) << 20));
;;;245      /* Write to SAI_Block_x CR1 */
;;;246      SAI_Block_x->CR1 = tmpreg;
000032  6010              STR      r0,[r2,#0]
;;;247      
;;;248      /* SAI Block_x CR2 Configuration */
;;;249      /* Get the SAIBlock_x CR2 value */
;;;250      tmpreg = SAI_Block_x->CR2;
000034  6850              LDR      r0,[r2,#4]
;;;251      /* Clear FTH bits */
;;;252      tmpreg &= ~(SAI_xCR2_FTH);
000036  f0200003          BIC      r0,r0,#3
;;;253      /* Configure the FIFO Level */
;;;254      /* Set FTH bits according to SAI_FIFOThreshold value */ 
;;;255      tmpreg |= (uint32_t)(SAI_InitStruct->SAI_FIFOThreshold);
00003a  6a4b              LDR      r3,[r1,#0x24]
00003c  4318              ORRS     r0,r0,r3
;;;256      /* Write to SAI_Block_x CR2 */
;;;257      SAI_Block_x->CR2 = tmpreg;
00003e  6050              STR      r0,[r2,#4]
;;;258    }
000040  bd10              POP      {r4,pc}
;;;259    
                          ENDP

000042  0000              DCW      0x0000
                  |L15.68|
                          DCD      0xff07c010

                          AREA ||i.SAI_MonoModeConfig||, CODE, READONLY, ALIGN=1

                  SAI_MonoModeConfig PROC
;;;460      */
;;;461    void SAI_MonoModeConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_Mono_StreoMode)
000000  6802              LDR      r2,[r0,#0]
;;;462    {
;;;463      /* Check the parameters */
;;;464      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;465      assert_param(IS_SAI_BLOCK_MONO_STREO_MODE(SAI_MonoMode));
;;;466      /* Clear MONO bit */
;;;467      SAI_Block_x->CR1 &= ~(SAI_xCR1_MONO);
000002  f4225280          BIC      r2,r2,#0x1000
000006  6002              STR      r2,[r0,#0]
;;;468      /* Set new Mono Mode value */
;;;469      SAI_Block_x->CR1 |= SAI_MonoMode;
000008  6802              LDR      r2,[r0,#0]
00000a  f4425280          ORR      r2,r2,#0x1000
00000e  6002              STR      r2,[r0,#0]
;;;470    }
000010  4770              BX       lr
;;;471    
                          ENDP


                          AREA ||i.SAI_MuteFrameCounterConfig||, CODE, READONLY, ALIGN=1

                  SAI_MuteFrameCounterConfig PROC
;;;588      */
;;;589    void SAI_MuteFrameCounterConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_MuteCounter)
000000  6842              LDR      r2,[r0,#4]
;;;590    {
;;;591      /* Check the parameters */
;;;592      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;593      assert_param(IS_SAI_BLOCK_MUTE_COUNTER(SAI_MuteCounter));
;;;594      
;;;595      /* Clear Mute value bits */
;;;596      SAI_Block_x->CR2 &= ~(SAI_xCR2_MUTECNT);
000002  f42252fc          BIC      r2,r2,#0x1f80
000006  6042              STR      r2,[r0,#4]
;;;597      /* Set new Mute value */
;;;598      SAI_Block_x->CR2 |= (SAI_MuteCounter << 7);
000008  6842              LDR      r2,[r0,#4]
00000a  ea4212c1          ORR      r2,r2,r1,LSL #7
00000e  6042              STR      r2,[r0,#4]
;;;599    }
000010  4770              BX       lr
;;;600    
                          ENDP


                          AREA ||i.SAI_MuteModeCmd||, CODE, READONLY, ALIGN=1

                  SAI_MuteModeCmd PROC
;;;535      */
;;;536    void SAI_MuteModeCmd(SAI_Block_TypeDef* SAI_Block_x, FunctionalState NewState)
000000  b121              CBZ      r1,|L18.12|
;;;537    {
;;;538      /* Check the parameters */
;;;539      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;540      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;541      if (NewState != DISABLE)
;;;542      {
;;;543        /* Enable the selected SAI block mute mode */
;;;544        SAI_Block_x->CR2 |= SAI_xCR2_MUTE;
000002  6842              LDR      r2,[r0,#4]
000004  f0420220          ORR      r2,r2,#0x20
000008  6042              STR      r2,[r0,#4]
00000a  e003              B        |L18.20|
                  |L18.12|
;;;545      }
;;;546      else
;;;547      {
;;;548        /* Disable the selected SAI SS output */
;;;549        SAI_Block_x->CR2 &= ~(SAI_xCR2_MUTE);
00000c  6842              LDR      r2,[r0,#4]
00000e  f0220220          BIC      r2,r2,#0x20
000012  6042              STR      r2,[r0,#4]
                  |L18.20|
;;;550      }
;;;551    }
000014  4770              BX       lr
;;;552    
                          ENDP


                          AREA ||i.SAI_MuteValueConfig||, CODE, READONLY, ALIGN=1

                  SAI_MuteValueConfig PROC
;;;566      */
;;;567    void SAI_MuteValueConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_MuteValue)
000000  6842              LDR      r2,[r0,#4]
;;;568    {
;;;569      /* Check the parameters */
;;;570      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;571      assert_param(IS_SAI_BLOCK_MUTE_VALUE(SAI_MuteValue));
;;;572      
;;;573      /* Clear Mute value bits */
;;;574      SAI_Block_x->CR2 &= ~(SAI_xCR2_MUTEVAL);
000002  f0220240          BIC      r2,r2,#0x40
000006  6042              STR      r2,[r0,#4]
;;;575      /* Set new Mute value */
;;;576      SAI_Block_x->CR2 |= SAI_MuteValue;
000008  6842              LDR      r2,[r0,#4]
00000a  430a              ORRS     r2,r2,r1
00000c  6042              STR      r2,[r0,#4]
;;;577    }
00000e  4770              BX       lr
;;;578    
                          ENDP


                          AREA ||i.SAI_ReceiveData||, CODE, READONLY, ALIGN=1

                  SAI_ReceiveData PROC
;;;653      */
;;;654    uint32_t SAI_ReceiveData(SAI_Block_TypeDef* SAI_Block_x)
000000  4601              MOV      r1,r0
;;;655    {
;;;656      /* Check the parameters */
;;;657      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;658      
;;;659      /* Return the data in the DR register */
;;;660      return SAI_Block_x->DR;
000002  69c8              LDR      r0,[r1,#0x1c]
;;;661    }
000004  4770              BX       lr
;;;662    
                          ENDP


                          AREA ||i.SAI_SendData||, CODE, READONLY, ALIGN=1

                  SAI_SendData PROC
;;;669      */
;;;670    void SAI_SendData(SAI_Block_TypeDef* SAI_Block_x, uint32_t Data)
000000  61c1              STR      r1,[r0,#0x1c]
;;;671    {
;;;672      /* Check the parameters */
;;;673      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;674      
;;;675      /* Write in the DR register the data to be sent */
;;;676      SAI_Block_x->DR = Data;
;;;677    }
000002  4770              BX       lr
;;;678    
                          ENDP


                          AREA ||i.SAI_SlotInit||, CODE, READONLY, ALIGN=1

                  SAI_SlotInit PROC
;;;319      */
;;;320    void SAI_SlotInit(SAI_Block_TypeDef* SAI_Block_x, SAI_SlotInitTypeDef* SAI_SlotInitStruct)
000000  b510              PUSH     {r4,lr}
;;;321    {
;;;322      uint32_t tmpreg = 0;
000002  2200              MOVS     r2,#0
;;;323      
;;;324      /* Check the parameters */
;;;325      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;326      
;;;327      /* Check the SAI Block Slot parameters */
;;;328      assert_param(IS_SAI_BLOCK_FIRSTBIT_OFFSET(SAI_SlotInitStruct->SAI_FirstBitOffset));
;;;329      assert_param(IS_SAI_BLOCK_SLOT_SIZE(SAI_SlotInitStruct->SAI_SlotSize));
;;;330      assert_param(IS_SAI_BLOCK_SLOT_NUMBER(SAI_SlotInitStruct->SAI_SlotNumber));
;;;331      assert_param(IS_SAI_SLOT_ACTIVE(SAI_SlotInitStruct->SAI_SlotActive));
;;;332    
;;;333      /* SAI Block_x SLOTR Configuration */
;;;334      /* Get the SAI Block_x SLOTR value */
;;;335      tmpreg = SAI_Block_x->SLOTR;
000004  68c2              LDR      r2,[r0,#0xc]
;;;336      /* Clear FBOFF, SLOTSZ, NBSLOT, SLOTEN bits */
;;;337      tmpreg &= SLOTR_CLEAR_MASK;
000006  f24f0320          MOV      r3,#0xf020
00000a  401a              ANDS     r2,r2,r3
;;;338      /* Configure SAI_Block_x Slot: First bit offset, Slot size, Number of Slot in  
;;;339         audio frame and slots activated in audio frame */
;;;340      /* Set FBOFF bits according to SAI_FirstBitOffset value  */
;;;341      /* Set SLOTSZ bits according to SAI_SlotSize value       */
;;;342      /* Set NBSLOT bits according to SAI_SlotNumber value     */
;;;343      /* Set SLOTEN bits according to SAI_SlotActive value     */
;;;344      tmpreg |= (uint32_t)(SAI_SlotInitStruct->SAI_FirstBitOffset | 
00000c  e9d13400          LDRD     r3,r4,[r1,#0]
000010  4323              ORRS     r3,r3,r4
000012  68cc              LDR      r4,[r1,#0xc]
000014  4323              ORRS     r3,r3,r4
000016  688c              LDR      r4,[r1,#8]
000018  1e64              SUBS     r4,r4,#1
00001a  ea432304          ORR      r3,r3,r4,LSL #8
00001e  431a              ORRS     r2,r2,r3
;;;345                           SAI_SlotInitStruct->SAI_SlotSize       | 
;;;346                           SAI_SlotInitStruct->SAI_SlotActive     |    
;;;347                           (uint32_t)((SAI_SlotInitStruct->SAI_SlotNumber - 1) <<  8));
;;;348                           
;;;349      /* Write to SAI_Block_x SLOTR */
;;;350      SAI_Block_x->SLOTR = tmpreg;
000020  60c2              STR      r2,[r0,#0xc]
;;;351    }
000022  bd10              POP      {r4,pc}
;;;352    
                          ENDP


                          AREA ||i.SAI_SlotStructInit||, CODE, READONLY, ALIGN=1

                  SAI_SlotStructInit PROC
;;;410      */
;;;411    void SAI_SlotStructInit(SAI_SlotInitTypeDef* SAI_SlotInitStruct)
000000  2100              MOVS     r1,#0
;;;412    {
;;;413      /* Reset SAI Slot init structure parameters values */
;;;414      /* Initialize the SAI_FirstBitOffset member */
;;;415      SAI_SlotInitStruct->SAI_FirstBitOffset = 0;
000002  6001              STR      r1,[r0,#0]
;;;416      /* Initialize the SAI_SlotSize member */
;;;417      SAI_SlotInitStruct->SAI_SlotSize = SAI_SlotSize_DataSize;
000004  6041              STR      r1,[r0,#4]
;;;418      /* Initialize the SAI_SlotNumber member */
;;;419      SAI_SlotInitStruct->SAI_SlotNumber = 1;
000006  2101              MOVS     r1,#1
000008  6081              STR      r1,[r0,#8]
;;;420      /* Initialize the SAI_SlotActive member */
;;;421      SAI_SlotInitStruct->SAI_SlotActive = SAI_Slot_NotActive;
00000a  2100              MOVS     r1,#0
00000c  60c1              STR      r1,[r0,#0xc]
;;;422    
;;;423    }
00000e  4770              BX       lr
;;;424    
                          ENDP


                          AREA ||i.SAI_StructInit||, CODE, READONLY, ALIGN=1

                  SAI_StructInit PROC
;;;358      */
;;;359    void SAI_StructInit(SAI_InitTypeDef* SAI_InitStruct)
000000  2100              MOVS     r1,#0
;;;360    {
;;;361      /* Reset SAI init structure parameters values */
;;;362      /* Initialize the SAI_AudioMode member */
;;;363      SAI_InitStruct->SAI_AudioMode = SAI_Mode_MasterTx;
000002  6001              STR      r1,[r0,#0]
;;;364      /* Initialize the SAI_Protocol member */
;;;365      SAI_InitStruct->SAI_Protocol = SAI_Free_Protocol;
000004  6041              STR      r1,[r0,#4]
;;;366      /* Initialize the SAI_DataSize member */
;;;367      SAI_InitStruct->SAI_DataSize = SAI_DataSize_8b;
000006  2140              MOVS     r1,#0x40
000008  6081              STR      r1,[r0,#8]
;;;368      /* Initialize the SAI_FirstBit member */
;;;369      SAI_InitStruct->SAI_FirstBit = SAI_FirstBit_MSB;
00000a  2100              MOVS     r1,#0
00000c  60c1              STR      r1,[r0,#0xc]
;;;370      /* Initialize the SAI_ClockStrobing member */
;;;371      SAI_InitStruct->SAI_ClockStrobing = SAI_ClockStrobing_FallingEdge;
00000e  6101              STR      r1,[r0,#0x10]
;;;372      /* Initialize the SAI_Synchro member */
;;;373      SAI_InitStruct->SAI_Synchro = SAI_Asynchronous;
000010  6141              STR      r1,[r0,#0x14]
;;;374      /* Initialize the SAI_OUTDRIV member */
;;;375      SAI_InitStruct->SAI_OUTDRIV = SAI_OutputDrive_Disabled;
000012  6181              STR      r1,[r0,#0x18]
;;;376      /* Initialize the SAI_NoDivider member */
;;;377      SAI_InitStruct->SAI_NoDivider = SAI_MasterDivider_Enabled;
000014  61c1              STR      r1,[r0,#0x1c]
;;;378      /* Initialize the SAI_MasterDivider member */
;;;379      SAI_InitStruct->SAI_MasterDivider = 0;
000016  6201              STR      r1,[r0,#0x20]
;;;380      /* Initialize the SAI_FIFOThreshold member */
;;;381      SAI_InitStruct->SAI_FIFOThreshold = SAI_Threshold_FIFOEmpty;
000018  6241              STR      r1,[r0,#0x24]
;;;382    }
00001a  4770              BX       lr
;;;383    
                          ENDP


                          AREA ||i.SAI_TRIStateConfig||, CODE, READONLY, ALIGN=1

                  SAI_TRIStateConfig PROC
;;;483      */
;;;484    void SAI_TRIStateConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_TRIState)
000000  6802              LDR      r2,[r0,#0]
;;;485    {
;;;486      /* Check the parameters */
;;;487      assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
;;;488      assert_param(IS_SAI_BLOCK_TRISTATE_MANAGEMENT(SAI_TRIState));
;;;489      /* Clear MONO bit */
;;;490      SAI_Block_x->CR1 &= ~(SAI_xCR1_MONO);
000002  f4225280          BIC      r2,r2,#0x1000
000006  6002              STR      r2,[r0,#0]
;;;491      /* Set new Mono Mode value */
;;;492      SAI_Block_x->CR1 |= SAI_MonoMode;  
000008  6802              LDR      r2,[r0,#0]
00000a  f4425280          ORR      r2,r2,#0x1000
00000e  6002              STR      r2,[r0,#0]
;;;493      
;;;494    }
000010  4770              BX       lr
;;;495    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Basic\\src\\stm32f4xx_sai.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_sai_c_191626f0____REV16|
#line 129 "..\\CMSIS\\core_cmInstr.h"
|__asm___15_stm32f4xx_sai_c_191626f0____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_sai_c_191626f0____REVSH|
#line 144
|__asm___15_stm32f4xx_sai_c_191626f0____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
