; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\spi.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\spi.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\Basic\inc -I..\HardWare\IIC -I..\HardWare\SPI -I..\HardWare\USART -I..\HardWare\W25QXX -I..\System\delay -I..\System\sys -I..\User -I..\CMSIS -I.\RTE\_Target_1 -ID:\ProgramFile\Keil5\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\ProgramFile\Keil5\ARM\CMSIS\Include -D__UVISION_VERSION=525 -DSTM32F405xx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\spi.crf ..\HardWare\SPI\spi.c]
                          THUMB

                          AREA ||i.SPI1_Init||, CODE, READONLY, ALIGN=2

                  SPI1_Init PROC
;;;18     //这里针是对SPI1的初始化
;;;19     void SPI1_Init(void)
000000  b500              PUSH     {lr}
;;;20     {	 
000002  b087              SUB      sp,sp,#0x1c
;;;21       GPIO_InitTypeDef  GPIO_InitStructure;
;;;22       SPI_InitTypeDef  SPI_InitStructure;
;;;23     	
;;;24       RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);//使能GPIOB时钟
000004  2101              MOVS     r1,#1
000006  2002              MOVS     r0,#2
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;25       RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);//使能SPI1时钟
00000c  2101              MOVS     r1,#1
00000e  0308              LSLS     r0,r1,#12
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;26      
;;;27       //GPIOFB3,4,5初始化设置
;;;28       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3|GPIO_Pin_4|GPIO_Pin_5;//PB3~5复用功能输出	
000014  2038              MOVS     r0,#0x38
000016  9005              STR      r0,[sp,#0x14]
;;;29       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;//复用功能
000018  2002              MOVS     r0,#2
00001a  f88d0018          STRB     r0,[sp,#0x18]
;;;30       GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;//推挽输出
00001e  2000              MOVS     r0,#0
000020  f88d001a          STRB     r0,[sp,#0x1a]
;;;31       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;//100MHz
000024  2003              MOVS     r0,#3
000026  f88d0019          STRB     r0,[sp,#0x19]
;;;32       GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;//上拉
00002a  2001              MOVS     r0,#1
00002c  f88d001b          STRB     r0,[sp,#0x1b]
;;;33       GPIO_Init(GPIOB, &GPIO_InitStructure);//初始化
000030  a905              ADD      r1,sp,#0x14
000032  4822              LDR      r0,|L1.188|
000034  f7fffffe          BL       GPIO_Init
;;;34     	
;;;35     	GPIO_PinAFConfig(GPIOB,GPIO_PinSource3,GPIO_AF_SPI1); //PB3复用为 SPI1
000038  2205              MOVS     r2,#5
00003a  2103              MOVS     r1,#3
00003c  481f              LDR      r0,|L1.188|
00003e  f7fffffe          BL       GPIO_PinAFConfig
;;;36     	GPIO_PinAFConfig(GPIOB,GPIO_PinSource4,GPIO_AF_SPI1); //PB4复用为 SPI1
000042  2205              MOVS     r2,#5
000044  2104              MOVS     r1,#4
000046  481d              LDR      r0,|L1.188|
000048  f7fffffe          BL       GPIO_PinAFConfig
;;;37     	GPIO_PinAFConfig(GPIOB,GPIO_PinSource5,GPIO_AF_SPI1); //PB5复用为 SPI1
00004c  2205              MOVS     r2,#5
00004e  4611              MOV      r1,r2
000050  481a              LDR      r0,|L1.188|
000052  f7fffffe          BL       GPIO_PinAFConfig
;;;38      
;;;39     	//这里只针对SPI口初始化
;;;40     	RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1,ENABLE);//复位SPI1
000056  2101              MOVS     r1,#1
000058  0308              LSLS     r0,r1,#12
00005a  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;41     	RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1,DISABLE);//停止复位SPI1
00005e  2100              MOVS     r1,#0
000060  f44f5080          MOV      r0,#0x1000
000064  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;42     
;;;43     	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;  //设置SPI单向或者双向的数据模式:SPI设置为双线双向全双工
000068  2000              MOVS     r0,#0
00006a  f8ad0000          STRH     r0,[sp,#0]
;;;44     	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;		//设置SPI工作模式:设置为主SPI
00006e  f44f7082          MOV      r0,#0x104
000072  f8ad0002          STRH     r0,[sp,#2]
;;;45     	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;		//设置SPI的数据大小:SPI发送接收8位帧结构
000076  2000              MOVS     r0,#0
000078  f8ad0004          STRH     r0,[sp,#4]
;;;46     	SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;		//串行同步时钟的空闲状态为高电平
00007c  2002              MOVS     r0,#2
00007e  f8ad0006          STRH     r0,[sp,#6]
;;;47     	SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;	//串行同步时钟的第二个跳变沿（上升或下降）数据被采样
000082  2001              MOVS     r0,#1
000084  f8ad0008          STRH     r0,[sp,#8]
;;;48     	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;		//NSS信号由硬件（NSS管脚）还是软件（使用SSI位）管理:内部NSS信号有SSI位控制
000088  0240              LSLS     r0,r0,#9
00008a  f8ad000a          STRH     r0,[sp,#0xa]
;;;49     	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256;		//定义波特率预分频的值:波特率预分频值为256
00008e  2038              MOVS     r0,#0x38
000090  f8ad000c          STRH     r0,[sp,#0xc]
;;;50     	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;	//指定数据传输从MSB位还是LSB位开始:数据传输从MSB位开始
000094  2000              MOVS     r0,#0
000096  f8ad000e          STRH     r0,[sp,#0xe]
;;;51     	SPI_InitStructure.SPI_CRCPolynomial = 7;	//CRC值计算的多项式
00009a  2007              MOVS     r0,#7
00009c  f8ad0010          STRH     r0,[sp,#0x10]
;;;52     	SPI_Init(SPI1, &SPI_InitStructure);  //根据SPI_InitStruct中指定的参数初始化外设SPIx寄存器
0000a0  4669              MOV      r1,sp
0000a2  4807              LDR      r0,|L1.192|
0000a4  f7fffffe          BL       SPI_Init
;;;53      
;;;54     	SPI_Cmd(SPI1, ENABLE); //使能SPI外设
0000a8  2101              MOVS     r1,#1
0000aa  4805              LDR      r0,|L1.192|
0000ac  f7fffffe          BL       SPI_Cmd
;;;55     
;;;56     	SPI1_ReadWriteByte(0xff);//启动传输		 
0000b0  20ff              MOVS     r0,#0xff
0000b2  f7fffffe          BL       SPI1_ReadWriteByte
;;;57     }   
0000b6  b007              ADD      sp,sp,#0x1c
0000b8  bd00              POP      {pc}
;;;58     //SPI1速度设置函数
                          ENDP

0000ba  0000              DCW      0x0000
                  |L1.188|
                          DCD      0x40020400
                  |L1.192|
                          DCD      0x40013000

                          AREA ||i.SPI1_ReadWriteByte||, CODE, READONLY, ALIGN=2

                  SPI1_ReadWriteByte PROC
;;;71     //返回值:读取到的字节
;;;72     u8 SPI1_ReadWriteByte(u8 TxData)
000000  b510              PUSH     {r4,lr}
;;;73     {		 			 
000002  4604              MOV      r4,r0
;;;74      
;;;75       while (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET){}//等待发送区空  
000004  bf00              NOP      
                  |L2.6|
000006  2102              MOVS     r1,#2
000008  480a              LDR      r0,|L2.52|
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L2.6|
;;;76     	
;;;77     	SPI_I2S_SendData(SPI1, TxData); //通过外设SPIx发送一个byte  数据
000012  4621              MOV      r1,r4
000014  4807              LDR      r0,|L2.52|
000016  f7fffffe          BL       SPI_I2S_SendData
;;;78     		
;;;79       while (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET){} //等待接收完一个byte  
00001a  bf00              NOP      
                  |L2.28|
00001c  2101              MOVS     r1,#1
00001e  4805              LDR      r0,|L2.52|
000020  f7fffffe          BL       SPI_I2S_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d0f9              BEQ      |L2.28|
;;;80      
;;;81     	return SPI_I2S_ReceiveData(SPI1); //返回通过SPIx最近接收的数据	
000028  4802              LDR      r0,|L2.52|
00002a  f7fffffe          BL       SPI_I2S_ReceiveData
00002e  b2c0              UXTB     r0,r0
;;;82      		    
;;;83     }
000030  bd10              POP      {r4,pc}
;;;84     
                          ENDP

000032  0000              DCW      0x0000
                  |L2.52|
                          DCD      0x40013000

                          AREA ||i.SPI1_SetSpeed||, CODE, READONLY, ALIGN=2

                  SPI1_SetSpeed PROC
;;;61     //fAPB2时钟一般为84Mhz：
;;;62     void SPI1_SetSpeed(u8 SPI_BaudRatePrescaler)
000000  b510              PUSH     {r4,lr}
;;;63     {
000002  4604              MOV      r4,r0
;;;64       assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_BaudRatePrescaler));//判断有效性
;;;65     	SPI1->CR1&=0XFFC7;//位3-5清零，用来设置波特率
000004  4807              LDR      r0,|L3.36|
000006  8800              LDRH     r0,[r0,#0]
000008  f64f71c7          MOV      r1,#0xffc7
00000c  4008              ANDS     r0,r0,r1
00000e  4905              LDR      r1,|L3.36|
000010  8008              STRH     r0,[r1,#0]
;;;66     	SPI1->CR1|=SPI_BaudRatePrescaler;	//设置SPI1速度 
000012  4608              MOV      r0,r1
000014  8800              LDRH     r0,[r0,#0]
000016  4320              ORRS     r0,r0,r4
000018  8008              STRH     r0,[r1,#0]
;;;67     	SPI_Cmd(SPI1,ENABLE); //使能SPI1
00001a  2101              MOVS     r1,#1
00001c  4801              LDR      r0,|L3.36|
00001e  f7fffffe          BL       SPI_Cmd
;;;68     } 
000022  bd10              POP      {r4,pc}
;;;69     //SPI1 读写一个字节
                          ENDP

                  |L3.36|
                          DCD      0x40013000

;*** Start embedded assembler ***

#line 1 "..\\HardWare\\SPI\\spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_1b04b235____REV16|
#line 129 "..\\CMSIS\\core_cmInstr.h"
|__asm___5_spi_c_1b04b235____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_1b04b235____REVSH|
#line 144
|__asm___5_spi_c_1b04b235____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
