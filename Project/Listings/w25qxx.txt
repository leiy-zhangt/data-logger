; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\w25qxx.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\w25qxx.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\Basic\inc -I..\HardWare\IIC -I..\HardWare\SPI -I..\HardWare\USART -I..\HardWare\W25QXX -I..\System\delay -I..\System\sys -I..\User -I..\CMSIS -I.\RTE\_Target_1 -ID:\ProgramFile\Keil5\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\ProgramFile\Keil5\ARM\CMSIS\Include -D__UVISION_VERSION=525 -DSTM32F405xx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\w25qxx.crf ..\HardWare\W25QXX\w25qxx.c]
                          THUMB

                          AREA ||i.W25QXX_Erase_Chip||, CODE, READONLY, ALIGN=2

                  W25QXX_Erase_Chip PROC
;;;221    //等待时间超长...
;;;222    void W25QXX_Erase_Chip(void)   
000000  b510              PUSH     {r4,lr}
;;;223    {                                   
;;;224        W25QXX_Write_Enable();                  //SET WEL 
000002  f7fffffe          BL       W25QXX_Write_Enable
;;;225        W25QXX_Wait_Busy();   
000006  f7fffffe          BL       W25QXX_Wait_Busy
;;;226      	W25QXX_CS=0;                            //使能器件   
00000a  2000              MOVS     r0,#0
00000c  4905              LDR      r1,|L1.36|
00000e  6008              STR      r0,[r1,#0]
;;;227        SPI1_ReadWriteByte(W25X_ChipErase);        //发送片擦除命令  
000010  20c7              MOVS     r0,#0xc7
000012  f7fffffe          BL       SPI1_ReadWriteByte
;;;228    	W25QXX_CS=1;                            //取消片选     	      
000016  2001              MOVS     r0,#1
000018  4903              LDR      r1,|L1.40|
00001a  f8c102b8          STR      r0,[r1,#0x2b8]
;;;229    	W25QXX_Wait_Busy();   				   //等待芯片擦除结束
00001e  f7fffffe          BL       W25QXX_Wait_Busy
;;;230    }   
000022  bd10              POP      {r4,pc}
;;;231    //擦除一个扇区
                          ENDP

                  |L1.36|
                          DCD      0x424082b8
                  |L1.40|
                          DCD      0x42408000

                          AREA ||i.W25QXX_Erase_Sector||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  W25QXX_Erase_Sector PROC
;;;233    //擦除一个山区的最少时间:150ms
;;;234    void W25QXX_Erase_Sector(u32 Dst_Addr)   
000000  b510              PUSH     {r4,lr}
;;;235    {  
000002  4604              MOV      r4,r0
;;;236    	//监视falsh擦除情况,测试用   
;;;237     	printf("fe:%x\r\n",Dst_Addr);	  
000004  4621              MOV      r1,r4
000006  a010              ADR      r0,|L2.72|
000008  f7fffffe          BL       __2printf
;;;238     	Dst_Addr*=4096;
00000c  0324              LSLS     r4,r4,#12
;;;239        W25QXX_Write_Enable();                  //SET WEL 	 
00000e  f7fffffe          BL       W25QXX_Write_Enable
;;;240        W25QXX_Wait_Busy();   
000012  f7fffffe          BL       W25QXX_Wait_Busy
;;;241      	W25QXX_CS=0;                            //使能器件   
000016  2000              MOVS     r0,#0
000018  490d              LDR      r1,|L2.80|
00001a  6008              STR      r0,[r1,#0]
;;;242        SPI1_ReadWriteByte(W25X_SectorErase);      //发送扇区擦除指令 
00001c  2020              MOVS     r0,#0x20
00001e  f7fffffe          BL       SPI1_ReadWriteByte
;;;243        SPI1_ReadWriteByte((u8)((Dst_Addr)>>16));  //发送24bit地址    
000022  f3c44007          UBFX     r0,r4,#16,#8
000026  f7fffffe          BL       SPI1_ReadWriteByte
;;;244        SPI1_ReadWriteByte((u8)((Dst_Addr)>>8));   
00002a  f3c42007          UBFX     r0,r4,#8,#8
00002e  f7fffffe          BL       SPI1_ReadWriteByte
;;;245        SPI1_ReadWriteByte((u8)Dst_Addr);  
000032  b2e0              UXTB     r0,r4
000034  f7fffffe          BL       SPI1_ReadWriteByte
;;;246    	W25QXX_CS=1;                            //取消片选     	      
000038  2001              MOVS     r0,#1
00003a  4906              LDR      r1,|L2.84|
00003c  f8c102b8          STR      r0,[r1,#0x2b8]
;;;247        W25QXX_Wait_Busy();   				   //等待擦除完成
000040  f7fffffe          BL       W25QXX_Wait_Busy
;;;248    }  
000044  bd10              POP      {r4,pc}
;;;249    //等待空闲
                          ENDP

000046  0000              DCW      0x0000
                  |L2.72|
000048  66653a25          DCB      "fe:%x\r\n",0
00004c  780d0a00
                  |L2.80|
                          DCD      0x424082b8
                  |L2.84|
                          DCD      0x42408000

                          AREA ||i.W25QXX_Init||, CODE, READONLY, ALIGN=2

                  W25QXX_Init PROC
;;;16     //初始化SPI FLASH的IO口
;;;17     void W25QXX_Init(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;18     { 
;;;19       GPIO_InitTypeDef  GPIO_InitStructure;
;;;20      
;;;21       RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);//使能GPIOB时钟
000002  2101              MOVS     r1,#1
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;22       RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOG, ENABLE);//使能GPIOG时钟
00000a  2101              MOVS     r1,#1
00000c  2040              MOVS     r0,#0x40
00000e  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;23     
;;;24     	  //GPIOB14
;;;25       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;//PB14
000012  f44f4080          MOV      r0,#0x4000
000016  9000              STR      r0,[sp,#0]
;;;26       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;//输出
000018  2001              MOVS     r0,#1
00001a  f88d0004          STRB     r0,[sp,#4]
;;;27       GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;//推挽输出
00001e  2000              MOVS     r0,#0
000020  f88d0006          STRB     r0,[sp,#6]
;;;28       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;//100MHz
000024  2003              MOVS     r0,#3
000026  f88d0005          STRB     r0,[sp,#5]
;;;29       GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;//上拉
00002a  2001              MOVS     r0,#1
00002c  f88d0007          STRB     r0,[sp,#7]
;;;30       GPIO_Init(GPIOB, &GPIO_InitStructure);//初始化
000030  4669              MOV      r1,sp
000032  480d              LDR      r0,|L3.104|
000034  f7fffffe          BL       GPIO_Init
;;;31     
;;;32     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;//PG7
000038  2080              MOVS     r0,#0x80
00003a  9000              STR      r0,[sp,#0]
;;;33       GPIO_Init(GPIOG, &GPIO_InitStructure);//初始化
00003c  4669              MOV      r1,sp
00003e  480b              LDR      r0,|L3.108|
000040  f7fffffe          BL       GPIO_Init
;;;34      
;;;35     	GPIO_SetBits(GPIOG,GPIO_Pin_7);//PG7输出1,防止NRF干扰SPI FLASH的通信 
000044  2180              MOVS     r1,#0x80
000046  4809              LDR      r0,|L3.108|
000048  f7fffffe          BL       GPIO_SetBits
;;;36     	W25QXX_CS=1;			//SPI FLASH不选中
00004c  2001              MOVS     r0,#1
00004e  4908              LDR      r1,|L3.112|
000050  6008              STR      r0,[r1,#0]
;;;37     	SPI1_Init();		   			//初始化SPI
000052  f7fffffe          BL       SPI1_Init
;;;38     	SPI1_SetSpeed(SPI_BaudRatePrescaler_4);		//设置为21M时钟
000056  2008              MOVS     r0,#8
000058  f7fffffe          BL       SPI1_SetSpeed
;;;39     	W25QXX_TYPE=W25QXX_ReadID();	//读取FLASH ID.
00005c  f7fffffe          BL       W25QXX_ReadID
000060  4904              LDR      r1,|L3.116|
000062  8008              STRH     r0,[r1,#0]
;;;40     }  
000064  bd1c              POP      {r2-r4,pc}
;;;41     
                          ENDP

000066  0000              DCW      0x0000
                  |L3.104|
                          DCD      0x40020400
                  |L3.108|
                          DCD      0x40021800
                  |L3.112|
                          DCD      0x424082b8
                  |L3.116|
                          DCD      W25QXX_TYPE

                          AREA ||i.W25QXX_PowerDown||, CODE, READONLY, ALIGN=2

                  W25QXX_PowerDown PROC
;;;254    //进入掉电模式
;;;255    void W25QXX_PowerDown(void)   
000000  b510              PUSH     {r4,lr}
;;;256    { 
;;;257      	W25QXX_CS=0;                            //使能器件   
000002  2000              MOVS     r0,#0
000004  4906              LDR      r1,|L4.32|
000006  6008              STR      r0,[r1,#0]
;;;258        SPI1_ReadWriteByte(W25X_PowerDown);        //发送掉电命令  
000008  20b9              MOVS     r0,#0xb9
00000a  f7fffffe          BL       SPI1_ReadWriteByte
;;;259    	W25QXX_CS=1;                            //取消片选     	      
00000e  2001              MOVS     r0,#1
000010  4904              LDR      r1,|L4.36|
000012  f8c102b8          STR      r0,[r1,#0x2b8]
;;;260        delay_us(3);                               //等待TPD  
000016  2003              MOVS     r0,#3
000018  f7fffffe          BL       delay_us
;;;261    }   
00001c  bd10              POP      {r4,pc}
;;;262    //唤醒
                          ENDP

00001e  0000              DCW      0x0000
                  |L4.32|
                          DCD      0x424082b8
                  |L4.36|
                          DCD      0x42408000

                          AREA ||i.W25QXX_Read||, CODE, READONLY, ALIGN=2

                  W25QXX_Read PROC
;;;108    //NumByteToRead:要读取的字节数(最大65535)
;;;109    void W25QXX_Read(u8* pBuffer,u32 ReadAddr,u16 NumByteToRead)   
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;110    { 
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
;;;111     	u16 i;   										    
;;;112    	W25QXX_CS=0;                            //使能器件   
00000a  2000              MOVS     r0,#0
00000c  490f              LDR      r1,|L5.76|
00000e  6008              STR      r0,[r1,#0]
;;;113        SPI1_ReadWriteByte(W25X_ReadData);         //发送读取命令   
000010  2003              MOVS     r0,#3
000012  f7fffffe          BL       SPI1_ReadWriteByte
;;;114        SPI1_ReadWriteByte((u8)((ReadAddr)>>16));  //发送24bit地址    
000016  f3c44007          UBFX     r0,r4,#16,#8
00001a  f7fffffe          BL       SPI1_ReadWriteByte
;;;115        SPI1_ReadWriteByte((u8)((ReadAddr)>>8));   
00001e  f3c42007          UBFX     r0,r4,#8,#8
000022  f7fffffe          BL       SPI1_ReadWriteByte
;;;116        SPI1_ReadWriteByte((u8)ReadAddr);   
000026  b2e0              UXTB     r0,r4
000028  f7fffffe          BL       SPI1_ReadWriteByte
;;;117        for(i=0;i<NumByteToRead;i++)
00002c  2500              MOVS     r5,#0
00002e  e005              B        |L5.60|
                  |L5.48|
;;;118    	{ 
;;;119            pBuffer[i]=SPI1_ReadWriteByte(0XFF);   //循环读数  
000030  20ff              MOVS     r0,#0xff
000032  f7fffffe          BL       SPI1_ReadWriteByte
000036  5570              STRB     r0,[r6,r5]
000038  1c68              ADDS     r0,r5,#1              ;117
00003a  b285              UXTH     r5,r0                 ;117
                  |L5.60|
00003c  42bd              CMP      r5,r7                 ;117
00003e  dbf7              BLT      |L5.48|
;;;120        }
;;;121    	W25QXX_CS=1;  				    	      
000040  2001              MOVS     r0,#1
000042  4902              LDR      r1,|L5.76|
000044  6008              STR      r0,[r1,#0]
;;;122    }  
000046  e8bd81f0          POP      {r4-r8,pc}
;;;123    //SPI在一页(0~65535)内写入少于256个字节的数据
                          ENDP

00004a  0000              DCW      0x0000
                  |L5.76|
                          DCD      0x424082b8

                          AREA ||i.W25QXX_ReadID||, CODE, READONLY, ALIGN=2

                  W25QXX_ReadID PROC
;;;90     //0XEF17,表示芯片型号为W25Q128 	  
;;;91     u16 W25QXX_ReadID(void)
000000  b510              PUSH     {r4,lr}
;;;92     {
;;;93     	u16 Temp = 0;	  
000002  2400              MOVS     r4,#0
;;;94     	W25QXX_CS=0;				    
000004  2000              MOVS     r0,#0
000006  490e              LDR      r1,|L6.64|
000008  6008              STR      r0,[r1,#0]
;;;95     	SPI1_ReadWriteByte(0x90);//发送读取ID命令	    
00000a  2090              MOVS     r0,#0x90
00000c  f7fffffe          BL       SPI1_ReadWriteByte
;;;96     	SPI1_ReadWriteByte(0x00); 	    
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       SPI1_ReadWriteByte
;;;97     	SPI1_ReadWriteByte(0x00); 	    
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       SPI1_ReadWriteByte
;;;98     	SPI1_ReadWriteByte(0x00); 	 			   
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       SPI1_ReadWriteByte
;;;99     	Temp|=SPI1_ReadWriteByte(0xFF)<<8;  
000022  20ff              MOVS     r0,#0xff
000024  f7fffffe          BL       SPI1_ReadWriteByte
000028  ea442400          ORR      r4,r4,r0,LSL #8
;;;100    	Temp|=SPI1_ReadWriteByte(0xFF);	 
00002c  20ff              MOVS     r0,#0xff
00002e  f7fffffe          BL       SPI1_ReadWriteByte
000032  4304              ORRS     r4,r4,r0
;;;101    	W25QXX_CS=1;				    
000034  2001              MOVS     r0,#1
000036  4903              LDR      r1,|L6.68|
000038  f8c102b8          STR      r0,[r1,#0x2b8]
;;;102    	return Temp;
00003c  4620              MOV      r0,r4
;;;103    }   		    
00003e  bd10              POP      {r4,pc}
;;;104    //读取SPI FLASH  
                          ENDP

                  |L6.64|
                          DCD      0x424082b8
                  |L6.68|
                          DCD      0x42408000

                          AREA ||i.W25QXX_ReadSR||, CODE, READONLY, ALIGN=2

                  W25QXX_ReadSR PROC
;;;49     //默认:0x00
;;;50     u8 W25QXX_ReadSR(void)   
000000  b510              PUSH     {r4,lr}
;;;51     {  
;;;52     	u8 byte=0;   
000002  2400              MOVS     r4,#0
;;;53     	W25QXX_CS=0;                            //使能器件   
000004  2000              MOVS     r0,#0
000006  4907              LDR      r1,|L7.36|
000008  6008              STR      r0,[r1,#0]
;;;54     	SPI1_ReadWriteByte(W25X_ReadStatusReg);    //发送读取状态寄存器命令    
00000a  2005              MOVS     r0,#5
00000c  f7fffffe          BL       SPI1_ReadWriteByte
;;;55     	byte=SPI1_ReadWriteByte(0Xff);             //读取一个字节  
000010  20ff              MOVS     r0,#0xff
000012  f7fffffe          BL       SPI1_ReadWriteByte
000016  4604              MOV      r4,r0
;;;56     	W25QXX_CS=1;                            //取消片选     
000018  2001              MOVS     r0,#1
00001a  4903              LDR      r1,|L7.40|
00001c  f8c102b8          STR      r0,[r1,#0x2b8]
;;;57     	return byte;   
000020  4620              MOV      r0,r4
;;;58     } 
000022  bd10              POP      {r4,pc}
;;;59     //写W25QXX状态寄存器
                          ENDP

                  |L7.36|
                          DCD      0x424082b8
                  |L7.40|
                          DCD      0x42408000

                          AREA ||i.W25QXX_WAKEUP||, CODE, READONLY, ALIGN=2

                  W25QXX_WAKEUP PROC
;;;262    //唤醒
;;;263    void W25QXX_WAKEUP(void)   
000000  b510              PUSH     {r4,lr}
;;;264    {  
;;;265      	W25QXX_CS=0;                            //使能器件   
000002  2000              MOVS     r0,#0
000004  4906              LDR      r1,|L8.32|
000006  6008              STR      r0,[r1,#0]
;;;266        SPI1_ReadWriteByte(W25X_ReleasePowerDown);   //  send W25X_PowerDown command 0xAB    
000008  20ab              MOVS     r0,#0xab
00000a  f7fffffe          BL       SPI1_ReadWriteByte
;;;267    	W25QXX_CS=1;                            //取消片选     	      
00000e  2001              MOVS     r0,#1
000010  4904              LDR      r1,|L8.36|
000012  f8c102b8          STR      r0,[r1,#0x2b8]
;;;268        delay_us(3);                               //等待TRES1
000016  2003              MOVS     r0,#3
000018  f7fffffe          BL       delay_us
;;;269    }   
00001c  bd10              POP      {r4,pc}
;;;270    
                          ENDP

00001e  0000              DCW      0x0000
                  |L8.32|
                          DCD      0x424082b8
                  |L8.36|
                          DCD      0x42408000

                          AREA ||i.W25QXX_Wait_Busy||, CODE, READONLY, ALIGN=1

                  W25QXX_Wait_Busy PROC
;;;249    //等待空闲
;;;250    void W25QXX_Wait_Busy(void)   
000000  b510              PUSH     {r4,lr}
;;;251    {   
;;;252    	while((W25QXX_ReadSR()&0x01)==0x01);   // 等待BUSY位清空
000002  bf00              NOP      
                  |L9.4|
000004  f7fffffe          BL       W25QXX_ReadSR
000008  f0000001          AND      r0,r0,#1
00000c  2800              CMP      r0,#0
00000e  d1f9              BNE      |L9.4|
;;;253    }  
000010  bd10              POP      {r4,pc}
;;;254    //进入掉电模式
                          ENDP


                          AREA ||i.W25QXX_Write||, CODE, READONLY, ALIGN=2

                  W25QXX_Write PROC
;;;175    u8 W25QXX_BUFFER[4096];		 
;;;176    void W25QXX_Write(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)   
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;177    { 
000004  4681              MOV      r9,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;178    	u32 secpos;
;;;179    	u16 secoff;
;;;180    	u16 secremain;	   
;;;181     	u16 i;    
;;;182    	u8 * W25QXX_BUF;	  
;;;183       	W25QXX_BUF=W25QXX_BUFFER;	     
00000a  f8dfb0a8          LDR      r11,|L10.180|
;;;184     	secpos=WriteAddr/4096;//扇区地址  
00000e  ea4f3817          LSR      r8,r7,#12
;;;185    	secoff=WriteAddr%4096;//在扇区内的偏移
000012  f3c70a0b          UBFX     r10,r7,#0,#12
;;;186    	secremain=4096-secoff;//扇区剩余空间大小   
000016  f5ca5480          RSB      r4,r10,#0x1000
;;;187     	//printf("ad:%X,nb:%X\r\n",WriteAddr,NumByteToWrite);//测试用
;;;188     	if(NumByteToWrite<=secremain)secremain=NumByteToWrite;//不大于4096个字节
00001a  42a6              CMP      r6,r4
00001c  dc00              BGT      |L10.32|
00001e  4634              MOV      r4,r6
                  |L10.32|
;;;189    	while(1) 
000020  e044              B        |L10.172|
                  |L10.34|
;;;190    	{	
;;;191    		W25QXX_Read(W25QXX_BUF,secpos*4096,4096);//读出整个扇区的内容
000022  ea4f3108          LSL      r1,r8,#12
000026  f44f5280          MOV      r2,#0x1000
00002a  4658              MOV      r0,r11
00002c  f7fffffe          BL       W25QXX_Read
;;;192    		for(i=0;i<secremain;i++)//校验数据
000030  2500              MOVS     r5,#0
000032  e008              B        |L10.70|
                  |L10.52|
;;;193    		{
;;;194    			if(W25QXX_BUF[secoff+i]!=0XFF)break;//需要擦除  	  
000034  eb0a0005          ADD      r0,r10,r5
000038  f81b0000          LDRB     r0,[r11,r0]
00003c  28ff              CMP      r0,#0xff
00003e  d000              BEQ      |L10.66|
000040  e003              B        |L10.74|
                  |L10.66|
000042  1c68              ADDS     r0,r5,#1              ;192
000044  b285              UXTH     r5,r0                 ;192
                  |L10.70|
000046  42a5              CMP      r5,r4                 ;192
000048  dbf4              BLT      |L10.52|
                  |L10.74|
00004a  bf00              NOP      
;;;195    		}
;;;196    		if(i<secremain)//需要擦除
00004c  42a5              CMP      r5,r4
00004e  da16              BGE      |L10.126|
;;;197    		{
;;;198    			W25QXX_Erase_Sector(secpos);//擦除这个扇区
000050  4640              MOV      r0,r8
000052  f7fffffe          BL       W25QXX_Erase_Sector
;;;199    			for(i=0;i<secremain;i++)	   //复制
000056  2500              MOVS     r5,#0
000058  e007              B        |L10.106|
                  |L10.90|
;;;200    			{
;;;201    				W25QXX_BUF[i+secoff]=pBuffer[i];	  
00005a  f8190005          LDRB     r0,[r9,r5]
00005e  eb05010a          ADD      r1,r5,r10
000062  f80b0001          STRB     r0,[r11,r1]
000066  1c68              ADDS     r0,r5,#1              ;199
000068  b285              UXTH     r5,r0                 ;199
                  |L10.106|
00006a  42a5              CMP      r5,r4                 ;199
00006c  dbf5              BLT      |L10.90|
;;;202    			}
;;;203    			W25QXX_Write_NoCheck(W25QXX_BUF,secpos*4096,4096);//写入整个扇区  
00006e  ea4f3108          LSL      r1,r8,#12
000072  f44f5280          MOV      r2,#0x1000
000076  4658              MOV      r0,r11
000078  f7fffffe          BL       W25QXX_Write_NoCheck
00007c  e004              B        |L10.136|
                  |L10.126|
;;;204    
;;;205    		}else W25QXX_Write_NoCheck(pBuffer,WriteAddr,secremain);//写已经擦除了的,直接写入扇区剩余区间. 				   
00007e  4622              MOV      r2,r4
000080  4639              MOV      r1,r7
000082  4648              MOV      r0,r9
000084  f7fffffe          BL       W25QXX_Write_NoCheck
                  |L10.136|
;;;206    		if(NumByteToWrite==secremain)break;//写入结束了
000088  42a6              CMP      r6,r4
00008a  d100              BNE      |L10.142|
00008c  e00f              B        |L10.174|
                  |L10.142|
;;;207    		else//写入未结束
;;;208    		{
;;;209    			secpos++;//扇区地址增1
00008e  f1080801          ADD      r8,r8,#1
;;;210    			secoff=0;//偏移位置为0 	 
000092  f04f0a00          MOV      r10,#0
;;;211    
;;;212    		   	pBuffer+=secremain;  //指针偏移
000096  44a1              ADD      r9,r9,r4
;;;213    			WriteAddr+=secremain;//写地址偏移	   
000098  4427              ADD      r7,r7,r4
;;;214    		   	NumByteToWrite-=secremain;				//字节数递减
00009a  1b30              SUBS     r0,r6,r4
00009c  b286              UXTH     r6,r0
;;;215    			if(NumByteToWrite>4096)secremain=4096;	//下一个扇区还是写不完
00009e  f5b65f80          CMP      r6,#0x1000
0000a2  dd02              BLE      |L10.170|
0000a4  f44f5480          MOV      r4,#0x1000
0000a8  e000              B        |L10.172|
                  |L10.170|
;;;216    			else secremain=NumByteToWrite;			//下一个扇区可以写完了
0000aa  4634              MOV      r4,r6
                  |L10.172|
0000ac  e7b9              B        |L10.34|
                  |L10.174|
0000ae  bf00              NOP                            ;206
;;;217    		}	 
;;;218    	};	 
;;;219    }
0000b0  e8bd9ff0          POP      {r4-r12,pc}
;;;220    //擦除整个芯片		  
                          ENDP

                  |L10.180|
                          DCD      W25QXX_BUFFER

                          AREA ||i.W25QXX_Write_Disable||, CODE, READONLY, ALIGN=2

                  W25QXX_Write_Disable PROC
;;;77     //将WEL清零  
;;;78     void W25QXX_Write_Disable(void)   
000000  b510              PUSH     {r4,lr}
;;;79     {  
;;;80     	W25QXX_CS=0;                            //使能器件   
000002  2000              MOVS     r0,#0
000004  4904              LDR      r1,|L11.24|
000006  6008              STR      r0,[r1,#0]
;;;81         SPI1_ReadWriteByte(W25X_WriteDisable);     //发送写禁止指令    
000008  2004              MOVS     r0,#4
00000a  f7fffffe          BL       SPI1_ReadWriteByte
;;;82     	W25QXX_CS=1;                            //取消片选     	      
00000e  2001              MOVS     r0,#1
000010  4902              LDR      r1,|L11.28|
000012  f8c102b8          STR      r0,[r1,#0x2b8]
;;;83     } 		
000016  bd10              POP      {r4,pc}
;;;84     //读取芯片ID
                          ENDP

                  |L11.24|
                          DCD      0x424082b8
                  |L11.28|
                          DCD      0x42408000

                          AREA ||i.W25QXX_Write_Enable||, CODE, READONLY, ALIGN=2

                  W25QXX_Write_Enable PROC
;;;69     //将WEL置位   
;;;70     void W25QXX_Write_Enable(void)   
000000  b510              PUSH     {r4,lr}
;;;71     {
;;;72     	W25QXX_CS=0;                            //使能器件   
000002  2000              MOVS     r0,#0
000004  4904              LDR      r1,|L12.24|
000006  6008              STR      r0,[r1,#0]
;;;73         SPI1_ReadWriteByte(W25X_WriteEnable);      //发送写使能  
000008  2006              MOVS     r0,#6
00000a  f7fffffe          BL       SPI1_ReadWriteByte
;;;74     	W25QXX_CS=1;                            //取消片选     	      
00000e  2001              MOVS     r0,#1
000010  4902              LDR      r1,|L12.28|
000012  f8c102b8          STR      r0,[r1,#0x2b8]
;;;75     } 
000016  bd10              POP      {r4,pc}
;;;76     //W25QXX写禁止	
                          ENDP

                  |L12.24|
                          DCD      0x424082b8
                  |L12.28|
                          DCD      0x42408000

                          AREA ||i.W25QXX_Write_NoCheck||, CODE, READONLY, ALIGN=1

                  W25QXX_Write_NoCheck PROC
;;;148    //CHECK OK
;;;149    void W25QXX_Write_NoCheck(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)   
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;150    { 			 		 
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;151    	u16 pageremain;	   
;;;152    	pageremain=256-WriteAddr%256; //单页剩余的字节数		 	    
00000a  b2f0              UXTB     r0,r6
00000c  f5c07580          RSB      r5,r0,#0x100
;;;153    	if(NumByteToWrite<=pageremain)pageremain=NumByteToWrite;//不大于256个字节
000010  42ac              CMP      r4,r5
000012  dc00              BGT      |L13.22|
000014  4625              MOV      r5,r4
                  |L13.22|
;;;154    	while(1)
000016  e012              B        |L13.62|
                  |L13.24|
;;;155    	{	   
;;;156    		W25QXX_Write_Page(pBuffer,WriteAddr,pageremain);
000018  462a              MOV      r2,r5
00001a  4631              MOV      r1,r6
00001c  4638              MOV      r0,r7
00001e  f7fffffe          BL       W25QXX_Write_Page
;;;157    		if(NumByteToWrite==pageremain)break;//写入结束了
000022  42ac              CMP      r4,r5
000024  d100              BNE      |L13.40|
000026  e00b              B        |L13.64|
                  |L13.40|
;;;158    	 	else //NumByteToWrite>pageremain
;;;159    		{
;;;160    			pBuffer+=pageremain;
000028  442f              ADD      r7,r7,r5
;;;161    			WriteAddr+=pageremain;	
00002a  442e              ADD      r6,r6,r5
;;;162    
;;;163    			NumByteToWrite-=pageremain;			  //减去已经写入了的字节数
00002c  1b60              SUBS     r0,r4,r5
00002e  b284              UXTH     r4,r0
;;;164    			if(NumByteToWrite>256)pageremain=256; //一次可以写入256个字节
000030  f5b47f80          CMP      r4,#0x100
000034  dd02              BLE      |L13.60|
000036  f44f7580          MOV      r5,#0x100
00003a  e000              B        |L13.62|
                  |L13.60|
;;;165    			else pageremain=NumByteToWrite; 	  //不够256个字节了
00003c  4625              MOV      r5,r4
                  |L13.62|
00003e  e7eb              B        |L13.24|
                  |L13.64|
000040  bf00              NOP                            ;157
;;;166    		}
;;;167    	};	    
;;;168    } 
000042  e8bd81f0          POP      {r4-r8,pc}
;;;169    //写SPI FLASH  
                          ENDP


                          AREA ||i.W25QXX_Write_Page||, CODE, READONLY, ALIGN=2

                  W25QXX_Write_Page PROC
;;;127    //NumByteToWrite:要写入的字节数(最大256),该数不应该超过该页的剩余字节数!!!	 
;;;128    void W25QXX_Write_Page(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;129    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
;;;130     	u16 i;  
;;;131        W25QXX_Write_Enable();                  //SET WEL 
00000a  f7fffffe          BL       W25QXX_Write_Enable
;;;132    	W25QXX_CS=0;                            //使能器件   
00000e  2000              MOVS     r0,#0
000010  490f              LDR      r1,|L14.80|
000012  6008              STR      r0,[r1,#0]
;;;133        SPI1_ReadWriteByte(W25X_PageProgram);      //发送写页命令   
000014  2002              MOVS     r0,#2
000016  f7fffffe          BL       SPI1_ReadWriteByte
;;;134        SPI1_ReadWriteByte((u8)((WriteAddr)>>16)); //发送24bit地址    
00001a  f3c44007          UBFX     r0,r4,#16,#8
00001e  f7fffffe          BL       SPI1_ReadWriteByte
;;;135        SPI1_ReadWriteByte((u8)((WriteAddr)>>8));   
000022  f3c42007          UBFX     r0,r4,#8,#8
000026  f7fffffe          BL       SPI1_ReadWriteByte
;;;136        SPI1_ReadWriteByte((u8)WriteAddr);   
00002a  b2e0              UXTB     r0,r4
00002c  f7fffffe          BL       SPI1_ReadWriteByte
;;;137        for(i=0;i<NumByteToWrite;i++)SPI1_ReadWriteByte(pBuffer[i]);//循环写数  
000030  2500              MOVS     r5,#0
000032  e004              B        |L14.62|
                  |L14.52|
000034  5d70              LDRB     r0,[r6,r5]
000036  f7fffffe          BL       SPI1_ReadWriteByte
00003a  1c68              ADDS     r0,r5,#1
00003c  b285              UXTH     r5,r0
                  |L14.62|
00003e  42bd              CMP      r5,r7
000040  dbf8              BLT      |L14.52|
;;;138    	W25QXX_CS=1;                            //取消片选 
000042  2001              MOVS     r0,#1
000044  4902              LDR      r1,|L14.80|
000046  6008              STR      r0,[r1,#0]
;;;139    	W25QXX_Wait_Busy();					   //等待写入结束
000048  f7fffffe          BL       W25QXX_Wait_Busy
;;;140    } 
00004c  e8bd81f0          POP      {r4-r8,pc}
;;;141    //无检验写SPI FLASH 
                          ENDP

                  |L14.80|
                          DCD      0x424082b8

                          AREA ||i.W25QXX_Write_SR||, CODE, READONLY, ALIGN=2

                  W25QXX_Write_SR PROC
;;;60     //只有SPR,TB,BP2,BP1,BP0(bit 7,5,4,3,2)可以写!!!
;;;61     void W25QXX_Write_SR(u8 sr)   
000000  b510              PUSH     {r4,lr}
;;;62     {   
000002  4604              MOV      r4,r0
;;;63     	W25QXX_CS=0;                            //使能器件   
000004  2000              MOVS     r0,#0
000006  4906              LDR      r1,|L15.32|
000008  6008              STR      r0,[r1,#0]
;;;64     	SPI1_ReadWriteByte(W25X_WriteStatusReg);   //发送写取状态寄存器命令    
00000a  2001              MOVS     r0,#1
00000c  f7fffffe          BL       SPI1_ReadWriteByte
;;;65     	SPI1_ReadWriteByte(sr);               //写入一个字节  
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       SPI1_ReadWriteByte
;;;66     	W25QXX_CS=1;                            //取消片选     	      
000016  2001              MOVS     r0,#1
000018  4902              LDR      r1,|L15.36|
00001a  f8c102b8          STR      r0,[r1,#0x2b8]
;;;67     }   
00001e  bd10              POP      {r4,pc}
;;;68     //W25QXX写使能	
                          ENDP

                  |L15.32|
                          DCD      0x424082b8
                  |L15.36|
                          DCD      0x42408000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  W25QXX_BUFFER
                          %        4096

                          AREA ||.data||, DATA, ALIGN=1

                  W25QXX_TYPE
000000  ef17              DCW      0xef17

;*** Start embedded assembler ***

#line 1 "..\\HardWare\\W25QXX\\w25qxx.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_w25qxx_c_7a854d5a____REV16|
#line 129 "..\\CMSIS\\core_cmInstr.h"
|__asm___8_w25qxx_c_7a854d5a____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_w25qxx_c_7a854d5a____REVSH|
#line 144
|__asm___8_w25qxx_c_7a854d5a____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
